# 1.类继承

- OOP编程的主要目的之一便是提供可重用的代码，使用已有的代码可以节省时间，也有助于避免在程序中引入错误，使程序员专注于程序的整体策略而不是某个具体的编程细节。
- 相比复制粘贴具有重复功能的代码，C++提供了比修改源代码更好的方法来扩展和修改类，这种方法被称为类继承。
- 类继承能够从已有的类派生出新的类，而派生类继承原有类（称为基类）的特征，包括方法。
- 继承的基本实现非常简单，但要对继承进行管理，使其在所有情况下都能够正常工作，则需要进行一些调整。稍后，你将会看到，C++为此衍生出了许多看起来有些复杂的规定。
- **我的看法：继承一个类并不难，难的是如何管理继承关系。正因如此，类的设计似乎也变得必须小心谨慎了。**

## 1.1公有继承

这是一个简单的例子：

```C++
//基类
class TableTennisPlayer
{
private:
  string firstname;
  string lastname;
  ...
public:
  TableTennisPlayer(const string &fn="none",const string &ln="none",...);
  void Name()const;
  bool HasTable()const{return hasTable;};
  ...
};
```

```C++
//派生类
//public关键字指出：TableTennisPlayer是一个公有基类，也被称为公有派生
class RatedPlayer:public TableTennisPlayer
{
private:
  //继承类新增的数据成员
  unsigned int  rating;
  ...
public:
  RatedPlayer(unsigned int r=0,const string &fn="none",const string &ln ="none",bool ht=false);
  //使用基类的构造函数
  RatedPlayer(unsigned int r,const TableTennisPlayer &tp);
  //继承类新增的成员函数
  unsigned int Rating()const {return rating;};
  ...
};
```

  上述代码完成了哪些工作？

- 派生类对象存储了基类的数据成员 **（派生类继承了基类的实现）**
- 派生类对象可以使用基类的方法 **（派生类继承了基类的接口）**
- **派生类需要自己的构造函数**
- **派生类可以根据需要添加额外的数据成员函数**
  
## 1.2 个人理解：继承关系的两个方面

派生类虽然继承了基类的很多特性，但是在操作这些特性的过程中，有很多需要注意的地方。在我看来，可以从以下两个方面分别讨论：

**1，基类和派生类存在逻辑上的先后关系，因此在创建和销毁派生类的时候需要考虑这一顺序。**
**2，派生类和基类都是类，都符合OOP的设计思想。具体的说，隐藏性，因此，数据是不能够被随意访问的，必须遵循一定的规则。**

## 1.3 公有继承：is-a 关系

对于像我这样的初学者而言，用一个具体的比喻来模拟抽象的逻辑可以帮助我快速入门某些概念。（这种比喻也许是有局限性的，但就目前而言，确实很有帮助）

is-a关系描述的是继承类之间的逻辑关系，这一点非常重要，因为这将直接影响到类的设计。可以这么认为（就我目前的认知而言），公有继承建立的就是is-a关系。

除此之外还有其他的许多关系，例如：

- has-a关系：午餐 has-a 水果
  公有继承不建立has-a关系，因为午餐可能包含水果，但午餐通常并不是水果。即你无法通过水果类派生出午餐类并在其中添加水果（如果你非要这么做，是可以的，但是会给自己制造很多麻烦）。简单的做法是：建立has-a关系，即午餐 has-a 水果。

- use-a关系：计算机use-a打印机
  公有继承不建立use-a关系，因为从计算机派生出打印机（或者反过来）来是没有意义的。然而，你可以使用友元来处理二者之间的通信。

- is-implemented-a(作为...实现)关系：数组is-implemented-a栈（可以使用数组实现栈）
  公有继承不建立is-implemented-a关系，因为栈并不是数组，况且，数组索引也并不是栈的属性。正确的做法是，你可以让栈类包含一个array数组成员并且隐藏它(私有化)。

- is-like-a关系：某人打篮球的样子 is-like-a 蔡徐坤
  公有继承不建立is-like-a关系，因为某人的技能属性和蔡徐坤半毛钱关系也没有。某人也许根本不会打篮球（球技很坏，但却是一个肌肉猛男），而后者却拥有唱，跳，Rap，篮球等高级属性。如果强行联系二者的继承关系，那么代码将会变得极其混乱。
等等。。。

书上的原话：“C++中，完全可以使用公有继承建立上述关系（is-like-a除外），然而这样做通常会导致编程方面的问题。因此，对于公有继承，还是坚持使用is-a关系吧。”

公有继承是继承关系里最简单和最符合人们直接思维的一种继承关系。一般情况下（也不排除有人使用公有继承实现诸如has-a等关系），它建立的是一种is-a关系。即派生对象也是一个基类对象，可以对基类对象执行的任何操作，也可以对派生类对象执行。

举例说明：

**芒果（我很喜欢的一种水果） is-a 水果。**
对于任何一个我们所认为的“水果”，它可以（人为规定）拥有以下简单的几个属性：重量，热量，产地，时令季节 等等
如果这些属性被芒果继承了，有毛病么？   **很显然，没毛病！水果有的属性，芒果同样也有。**
对于芒果而言，有它自己的属性：别名（青芒/黄芒），保存方法，食用方法 等等
问题来了：这些属性能被一般意义的水果概念引用么？  **很显然，不能！水果不一定都有别名，保存方法和使用方法也各不相同。**
芒果继承了水果的公共的，一般属性和特征，但新增了属于自己的特殊属性，这就是公有继承的形象化解释。

- **按照一般思维，当我们提到芒果这个概念时，我们已经承认它属于水果的一种了（除非你对芒果一无所知）。换句话说，芒果的概念常常伴随着一个前提条件：它是一种水果。**
- **我们可以说；芒果 is-a 水果。但是我们不能说：水果 is-a 芒果。**
  
芒果和水果的继承关系反映出了is-a关系继承过程中的两个主要方面：

**第一：继承有先后顺序之分，创建和销毁类对象时需要考虑这一顺序。**
**第二：is-a关系通常是不可逆的，派生类可以访问基类提供的资源，但基类无法访问派生类资源。**
以上两点构成了类继承关系管理的两个方面。

## 1.4 公有继承关系管理：构造函数

创建派生类对象时，C++首先创建基类对象。理解这一点很容易，因为基类提供了某些最基础的抽象，派生类是在这些抽象的基础上完成自己的功能的。
这就意味着基类对象应当在程序进入派生类构造函数之前被创建。为此，C++提供了相应的语法工具：成员初始化列表，来完成这一工作。

上述RatedPlayer类的构造函数代码看起来应该是这样：

```C++
RatedPlayer::RatedPlayer(unsigned int r,const string &fn,const string &ln ,bool ht):TableTennisPlayer(fn,ln,ht)
{
  rating=r;
}

RatedPlayer::RatedPlayer(unsigned int r,const TableTennisPlayer &tp):TableTennisPlayer(tp)
{
   rating=r;
}
```

如果程序员省略掉成员初始化列表，C++将使用默认的基类构造函数，等价于以下代码：

```C++
RatedPlayer::RatedPlayer(unsigned int r,const string &fn,const string &ln ,bool ht)//:TableTennisPlayer()
//TableTennisPlayer()可能是编译器自动生成的空的构造函数。
//总之，编译器总会保证基类在派生类之前被创建。
{
  rating=r;
}

RatedPlayer::RatedPlayer(unsigned int r,const TableTennisPlayer &tp)//:TableTennisPlayer()
{
   rating=r;
}
```

小结：对于派生类构造函数：

- **首先创建基类对象**
- **派生类构造函数应当通过成员初始化列表将基类信息传递给基类构造函数**
- **派生类构造函数应初始化派生类新增的数成员**

## 1.5 多态与虚函数

在上面的例子中，派生类对象使用基类的方法，而未做任何修改。然而，可能会遇到这样的情况，即希望同一个方法在派生类和基类中的行为是不同的。话句话说，方法的行为取决于调用该方法的对象。
**这种行为被称为多态——同一个方法的行为随上下文而异。**

有两种重要的机制可用于实现多态公有继承：

- 在派生类中重新定义基类的方法
- 使用虚方法

**虚方法“虚”在哪里？**

在派生类中重新定义基类的方法并不生成函数的两个重载版本。相反，无论参数列表是否相同，该操作将隐藏所有的同名基类的方法。

针对上述情况《C++ Primer Plus》（P506）给出了两条经验规则：

- 第一：如果重新定义了继承的方法，应确保与原来的原型完全相同，但如果返回类型是基类引用或者指针，则可以修改为指向派生类的引用或指针。
- 第二：如果基类声明被重载了，则应在派生类中重新定义所有的基类版本。


