**1. 内联函数**

- 使用内敛函数的目的在于消除转换指令以提高程序运行效率，但会付出内存上的代价（增加内存开销）。
- 内联函数是否真正实现取决于编译器的决策。
- 内联函数不能递归。
- 使用内联函数只需要在函数声明/函数定义前添加关键字“inline”即可
```c++
//声明阶段
inline double square(double x){return x*x;}
```

- 内联函数与宏的区别：
宏定义本质上只是字符替换，也就是说宏定义的函数并不真正支持参数传递的功能。
内联函数和常规函数一致，支持按值（更一般地说，支持表达式）传递函数参数，与普通函数无异。

- 内联函数的使用场景：

简短的并且经常被调用的函数使用内联函数的形式最合适。

**2. 引用**
- 引用是处理大型结构时的最佳选择
- 引用的本质是什么？
```C++
int a=100;
int & b=a;
//上面的引用定义等价于下面这句话
int* const b=&a;
```
**const 关键字表明int指针类型b的指向地址被锁定，换句话说，b只能指向a，而不能指向其他地址。**

**但是，const关键字只锁定了其指向的地址，但并未锁定指向的地址所在的内容。**

**使用引用时，必须在声明的时候对其进行初始化操作，不能像指针那样先声明后赋值。**

**一旦将引用与某个变量关联起来，就将一直效忠于该变量。**


**3. 将引用作为函数参数**
- 按值传递与按引用传递的区别
个人理解:对于函数而言，值传递意味着复制一份参数对象，如果未指定返回值，则这些复制的对象当且仅当在函数存在期间起作用，一旦函数调用结束，它们就会被立即释放掉。因此，这种方式在处理数据时局限性很大。引用是指针的一种简化版的写法（当然，在赋值的时候它跟指针还是有所区别的），引用的本质和指针一样，都是在传递地址。既然是在传递地址，那么也就意味着函数可以修改某些变量。正因如此，函数在处理大型数结构时（例如结构体以及类）将会有很高的效率。
- 引用的属性和特别之处

对于按值传递的参数，可以选择使用多种类型的实参，例如：
```C++
//如果定义了如下函数
double cube(double a);
//那么可以这样调用它：
double z=cube(x+2.0);
double z=cube(8.00);
int k=10;
double z=cube(k)//这里将int类型转换为long类型
double yo[3]={1.0,2.0,3.0};
doule z=cube(yo[1]);
```

对于按引用传递的参数，则有一定的限制条件

```C++
//定义如下函数：
double cube(double &a);
//无效的引用
double z=cube(x+2.0);
```
为什么以上引用无效？  因为x+3.0并不是变量，它仅仅只是一个表达式，更准确地说，这是一个非左值变量。

- 左值，什么是左值？

**左值是可以被引用的变量。**

**非左值包括字面常量，包含多项式的表达式。简而言之，非左值只有声明，但未被定义。换句话说，我们无法通过地址去访问他们**

引用在声明时必须对其进行初始化操作，对于函数参数而言，传递函数的过程就是复制，函数参数列表则是声明。如果引用被赋值给一个非左值变量，那么意味着该地址将无法访问，也就失去了初始化的意义。

- 临时变量和引用的关系

对于类型不匹配的引用，C++将生成临时变量。当且仅当const引用时，才允许这样做。因此，对于形参为const引用的C++函数，如果实参不匹配，C++将创建类型正确的匿名变量，将函数调用的参数的值传递给该匿名变量。这些匿名的临时变量只在函数调用期间存在，之后，编译器可以随意将其删除。

```C++
//如果有如下声明
double f(const double & a);
//那么以下引用成立
double a=2.0;
double * pd= &a;
double & r=a;

double c1=f(a);
double c2=f(rd);
double c3=F(
```

- 应当尽量使用const


使用const可以避免无意中修改数据的编程错误

使用const使函数能够正确处理const和非const实参，否则将只能接受非const数据

使用const引用使函数能够正确生成并使用临时变量





