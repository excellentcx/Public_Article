# 类设计知识点整理

### 1.构造函数

- 构造函数在完成其工作之前，类实例是不存在的。
- 默认构造函数要么没有参数，要么所有参数都有默认值。
- 构造函数不能被继承的原因之一在于：它创建新的对象，而其他类方法只是被现有的对象调用。
- 如果没有定义任何构造函数，编译器将自动定义一个默认构造函数。这么做的原因是：
  1. 使其能够创建对象实例（初始化类）。
  2. 调用基类的默认构造函数以及调用本身是对象的成员所属类的默认构造函数（继承关系下的初始化）。
- 如果派生类的构造函数成员初始化列表中没有显式调用基类的构造函数的话，便编译器将会使用基类的默认构造函数来构造派生类中包含基类的部分。如果基类没有主动提供构造函数，将会报错。
- 如果用户主动定义了某种构造函数，编译器将不会定义默认的构造函数。此时，用户只能自己提供默认的构造函数。
- 最好显式地提供一个默认构造函数，以此来确保对象被正确初始化，特别是初始化指针类成员的时候。
  
### 2.复制构造函数

- 复制构造函数用于以下场景
  1. 将新对象实例初始化为一个同类对象实例
  2. 按值将对象传递给函数
  3. 函数按值返回对象
  4. 编译器生成临时对象
- 如果程序没有使用（显式或者隐式）复制构造函数，编译器会自动提供原型，但不会提供定义。
- 如果程序使用（显式或者隐式）使用复制构造函数，程序将定义一个执行成员初始化的复制构造函数。也就是说，新对象的每个成员都会被初始化为原始对象相应的值。
- 在使用new的场合（此时通常需要执行深度复制），必须定义自己的复制构造函数。
  
### 3.赋值运算符
- 赋值运算符用于处理同类对象之间的赋值操作
- 默认赋值为类成员赋值，如果成员为某一类对象，那么将会调用该类所在的赋值运算符。
  
  
### 4.析构函数

- 一定要显式地定义析构函数来释放使用new分配的内存，并完成对象所需要的任何特殊清理工作。
-  对于基类，一定要显式地提供一个虚析构函数，即使它本身并不需要析构函数。
  
### 5.值传递和引用传递

- 值传递对象涉及到生成临时拷贝，即调用复制构造函数，然后调用析构函数，调用这些函数需要时间，赋值大型对象的时间比引用传递所花的时间要多得多。
- 基于上述原因，编写使用对象为参数的函数时，应使用引用的方式来传递对象。
- 在继承使用虚函数时，被定义为接受基类引用的参数的函数可以接受派生类。（基类指针可以管理派生类对象，引用本身就是指针的另一种表现形式。）

### 6.类型转换

- 使用有且仅有一个参数的构造函数可实现从参数类型到类类型的转换。
- 要将类对象转换为其他类型，应定义转换函数。转换函数可以是没有参数的类成员函数，也可以是返回类型被声明为目标类型的类成员函数。
- 使用转换函数有时会造成程序二义性，为了避免这种问题，应当使用explicit关键字将转换函数声明为强制性的显式转换，此时隐式转换被禁止。