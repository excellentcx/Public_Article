# 使用公有继承时，有很多问题需要注意

## 1. is-a关系

- 公有继承（最好）遵循is-a关系，如果派生类不是一种特殊的基类，则不要使用公有派生。例如：
  1. 水果类不能派生出午餐类，因为午餐通常包含水果，但水果通常不是午餐。
  2. 如果要指出午餐有水果，应将水果类对象作为午餐类的类成员。
- 最好的方法是（如果有必要）：创建包含纯虚函数的抽象数据类，并从他派生出其他的类。
- is-a关系无需进行显式的类型转换，即基类指针就可以管理基类和派生类（包括指向和引用）。但反过来是是不允许的，即派生类指针无法管理（包括指向和引用）基类对象。
- 如果非要这么做，那么只能在进行显式类型转换后，将派生类指针指向基类对象，但如此一来，会产生一定的危险性：
  
```C++
  //基类
  class Employee
  {
  private:
    char name[40];
    ...
  public:
    void show_name();
    ...
  };

  //派生类
  class Singer: public Employee
  {
    ...
  public:
    void range();
    ...
  };

  ...
  Employee a;
  Singer b;
  ...
  Employee *P=&b;//允许向上隐式类型转换（基类指针管理派生类）
  Singer *_P=(Singer *)a;//必须显式地向下类型转换（派生类指针管理被强制类型转换的基类对象）
  ...
  p->show_name();//向上类型转换带来安全操作：因为Singer是Employee（或者说，Singer具有Employee的一般属性）
  _P->range();//向下类型转换带来不安全操作，Employee不都是Singer，何谈range()属性一说？

```

- 上述示例表明：**is-a关系通常是不可逆的。**

## 2. 什么是不可以被继承的？

- 